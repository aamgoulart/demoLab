{"ast":null,"code":"import { Chart } from 'chart.js';\nimport { BaseChartDirective } from 'ng2-charts';\nimport { default as Annotation } from 'chartjs-plugin-annotation';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"ng2-charts\";\nimport * as i2 from \"@angular/material/button\";\nexport class ChartComponent {\n  constructor() {\n    this.newLabel = 'New label';\n    this.lineChartData = {\n      datasets: [{\n        data: [65, 59, 80, 81, 56, 55, 40, 30, 25, 20, -10, -20, -40, -50, -20, 10, 35, 40, 50, 60],\n        label: 'Sinal A',\n        backgroundColor: 'rgba(148,159,177,0.2)',\n        borderColor: 'rgba(148,159,177,1)',\n        pointBackgroundColor: 'rgba(148,159,177,1)',\n        pointBorderColor: '#fff',\n        pointHoverBackgroundColor: '#fff',\n        pointHoverBorderColor: 'rgba(148,159,177,0.8)',\n        fill: 'origin'\n      }],\n      labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    };\n    this.lineChartOptions = {\n      elements: {\n        line: {\n          tension: 0.5\n        }\n      },\n      scales: {\n        // We use this empty structure as a placeholder for dynamic theming.\n        y: {\n          position: 'left'\n        },\n        y1: {\n          position: 'right',\n          grid: {\n            color: 'rgba(255,0,0,0.3)'\n          }\n        }\n      }\n    };\n    this.lineChartType = 'line';\n    Chart.register(Annotation);\n  }\n  ngOnInit() {}\n  generateNumber(i) {\n    return Math.floor(Math.random() * (i < 2 ? 100 : 1000) + 1);\n  }\n  randomizarPorTempo() {\n    console.log(this.lineChartData.datasets);\n    setTimeout(() => {\n      this.lineChartData.datasets.forEach((x, i) => {\n        const num = Math.floor(Math.random() * 26) + 50;\n        ;\n        x.data.push(num);\n        console.log(this.lineChartData.datasets);\n      });\n      this.lineChartData?.labels?.push(`Label ${this.lineChartData.labels.length}`);\n      this.chart?.update();\n      setTimeout(this.randomizarPorTempo, 5000);\n    }, 3000);\n  }\n  startFunction() {\n    const intervalId = setInterval(() => {\n      this.pushOne();\n    }, 500);\n    // Parar de repetir a função após um determinado tempo (por exemplo, 30 segundos)\n    setTimeout(() => {\n      clearInterval(intervalId);\n    }, 30000000);\n  }\n  pushOne() {\n    const num = Math.floor(Math.random() * 26) + 50;\n    ;\n    console.log(this.lineChartData.datasets);\n    this.lineChartData.datasets.forEach((x, i) => {\n      x.data.push(num);\n    });\n    this.lineChartData?.labels?.push(`${this.lineChartData.labels.length}`);\n    this.chart?.update();\n  }\n  removeOne() {\n    this.lineChartData.datasets.forEach((x, i) => {\n      x.data.shift();\n    });\n    this.lineChartData?.labels?.shift();\n    this.chart?.update();\n  }\n  mostrarDados() {\n    this.startFunction();\n    this.iniciaRetirada();\n  }\n  iniciaRetirada() {\n    const intervalId = setInterval(() => {\n      this.removeOne();\n    }, 1000);\n    // Parar de repetir a função após um determinado tempo (por exemplo, 30 segundos)\n    setTimeout(() => {\n      clearInterval(intervalId);\n    }, 30000000);\n  }\n}\nChartComponent.ɵfac = function ChartComponent_Factory(t) {\n  return new (t || ChartComponent)();\n};\nChartComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: ChartComponent,\n  selectors: [[\"app-chart\"]],\n  viewQuery: function ChartComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(BaseChartDirective, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chart = _t.first);\n    }\n  },\n  decls: 5,\n  vars: 3,\n  consts: [[1, \"container\"], [\"baseChart\", \"\", 1, \"chart\", 3, \"data\", \"options\", \"type\"], [1, \"button-row\"], [\"mat-button\", \"\", \"mat-raised-button\", \"\", \"color\", \"primary\", 3, \"click\"]],\n  template: function ChartComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵelement(1, \"canvas\", 1);\n      i0.ɵɵelementStart(2, \"div\", 2)(3, \"button\", 3);\n      i0.ɵɵlistener(\"click\", function ChartComponent_Template_button_click_3_listener() {\n        return ctx.mostrarDados();\n      });\n      i0.ɵɵtext(4, \"Mostrar dados\");\n      i0.ɵɵelementEnd()()();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"data\", ctx.lineChartData)(\"options\", ctx.lineChartOptions)(\"type\", ctx.lineChartType);\n    }\n  },\n  dependencies: [i1.BaseChartDirective, i2.MatButton],\n  styles: [\"\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ== */\"]\n});","map":{"version":3,"mappings":"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","names":["Chart","BaseChartDirective","default","Annotation","ChartComponent","constructor","datasets","data","label","backgroundColor","borderColor","pointBackgroundColor","pointBorderColor","pointHoverBackgroundColor","pointHoverBorderColor","fill","labels","elements","line","tension","scales","y","position","y1","grid","color","register","ngOnInit","generateNumber","i","Math","floor","random","randomizarPorTempo","console","log","lineChartData","setTimeout","forEach","x","num","push","length","chart","update","startFunction","intervalId","setInterval","pushOne","clearInterval","removeOne","shift","mostrarDados","iniciaRetirada","selectors","viewQuery","i0","ctx"],"sourceRoot":"","sources":["/home/agoulart/projects/demoLab/src/app/chart/chart.component.ts","/home/agoulart/projects/demoLab/src/app/chart/chart.component.html"],"sourcesContent":["import { Component, OnInit, ViewChild } from '@angular/core';\nimport { Chart, ChartConfiguration, ChartEvent, ChartType } from 'chart.js';\nimport { BaseChartDirective } from 'ng2-charts';\n\nimport { default as Annotation } from 'chartjs-plugin-annotation';\n\n@Component({\n  selector: 'app-chart',\n  templateUrl: './chart.component.html',\n  styleUrls: ['./chart.component.css']\n})\nexport class ChartComponent implements OnInit {\n\n  private newLabel? = 'New label';\n\n  constructor() {\n    Chart.register(Annotation)\n  }\n\n  ngOnInit(): void {\n  }\n\n  public lineChartData: ChartConfiguration['data'] = {\n    datasets: [\n      {\n\n        data: [ 65, 59, 80, 81, 56, 55, 40 , 30, 25, 20, -10, -20, -40, -50, -20, 10, 35,40, 50, 60],\n        label: 'Sinal A',\n        backgroundColor: 'rgba(148,159,177,0.2)',\n        borderColor: 'rgba(148,159,177,1)',\n        pointBackgroundColor: 'rgba(148,159,177,1)',\n        pointBorderColor: '#fff',\n        pointHoverBackgroundColor: '#fff',\n        pointHoverBorderColor: 'rgba(148,159,177,0.8)',\n        fill: 'origin',\n      }\n    ],\n    labels: [1,2,3,4,5,6,7,8,9, 10, 11 , 12, 13, 14, 15, 16, 17, 18, 19, 20],\n  };\n\n  public lineChartOptions: ChartConfiguration['options'] = {\n    elements: {\n      line: {\n        tension: 0.5\n      }\n    },\n    scales: {\n      // We use this empty structure as a placeholder for dynamic theming.\n      y:\n        {\n          position: 'left',\n        },\n      y1: {\n        position: 'right',\n        grid: {\n          color: 'rgba(255,0,0,0.3)',\n        },\n\n      }\n    },\n\n  };\n\n  public lineChartType: ChartType = 'line';\n\n  @ViewChild(BaseChartDirective) chart?: BaseChartDirective;\n\n  generateNumber(i: number): number {\n    return Math.floor((Math.random() * (i < 2 ? 100 : 1000)) + 1);\n  }\n  randomizarPorTempo() {\n    console.log(this.lineChartData.datasets)\n    setTimeout(()=>{                           // <<<---using ()=> syntax\n      this.lineChartData.datasets.forEach((x, i) => {\n        const num = Math.floor(Math.random() * 26) + 50;;\n        x.data.push(num);\n        console.log(this.lineChartData.datasets)\n\n     });\n     this.lineChartData?.labels?.push(`Label ${ this.lineChartData.labels.length }`);\n\n     this.chart?.update();\n     setTimeout(this.randomizarPorTempo, 5000);\n    }, 3000);\n\n  }\n\n  startFunction() {\n    const intervalId = setInterval(() => {\n      this.pushOne();\n    }, 500);\n\n    // Parar de repetir a função após um determinado tempo (por exemplo, 30 segundos)\n    setTimeout(() => {\n      clearInterval(intervalId);\n    }, 30000000);\n  }\n\n  public pushOne(): void {\n    const num = Math.floor(Math.random() * 26) + 50;;\n\n    console.log(this.lineChartData.datasets)\n    this.lineChartData.datasets.forEach((x, i) => {\n       x.data.push(num);\n   });\n    this.lineChartData?.labels?.push(`${ this.lineChartData.labels.length }`);\n\n    this.chart?.update();\n  }\n\n  removeOne () {\n    this.lineChartData.datasets.forEach((x, i) => {\n      x.data.shift();\n    });\n   this.lineChartData?.labels?.shift();\n\n   this.chart?.update();\n  }\n\n  mostrarDados() {\n    this.startFunction();\n    this.iniciaRetirada();\n  }\n\n  iniciaRetirada() {\n    const intervalId = setInterval(() => {\n      this.removeOne();\n    }, 1000);\n\n    // Parar de repetir a função após um determinado tempo (por exemplo, 30 segundos)\n    setTimeout(() => {\n      clearInterval(intervalId);\n    }, 30000000);\n  }\n\n}\n","<div class=\"container\">\n  <canvas baseChart class=\"chart\"\n  [data]=\"lineChartData\"\n  [options]=\"lineChartOptions\"\n  [type]=\"lineChartType\"\n  ></canvas>\n\n<div class=\"button-row\">\n    <button mat-button mat-raised-button color=\"primary\" (click)=\"mostrarDados()\">Mostrar dados</button>\n</div>\n</div>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}